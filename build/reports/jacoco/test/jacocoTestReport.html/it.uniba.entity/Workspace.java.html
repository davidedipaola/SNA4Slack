<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Workspace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SNA4Slack</a> &gt; <a href="index.source.html" class="el_package">it.uniba.entity</a> &gt; <span class="el_source">Workspace.java</span></div><h1>Workspace.java</h1><pre class="source lang-java linenums">package it.uniba.entity;

import java.io.IOException;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;

import org.json.JSONArray;
import org.json.JSONObject;

import it.uniba.file.zip.FileNotInZipException;
import it.uniba.file.zip.NotValidWorkspaceException;
import it.uniba.file.zip.NotZipFileException;
import it.uniba.file.zip.Zip;

/**
 * Classe che modella il workspace.
 */
public final class Workspace {
	/**
	 * zip file.
	 */
	private Zip workspaceZip;
	/**
	 * lista di channel nel workspace.
	 */
	private LinkedHashMap&lt;String, Channel&gt; channels;
	/**
	 * lista di members nel workspace.
	 */
	private LinkedHashMap&lt;String, Member&gt; members;

	/**
	 * Metodo costruttore della classe workspace. Permette di creare oggetti istanze
	 * della classe workspace.
	 * 
	 * @param workspaceZipFile
	 *            String che rappresenta il percorso del workspace.
	 * @throws IOException
	 *             Lancia IOException se ci sono errori di input/output.
	 * @throws NotValidWorkspaceException
	 *             Lancia NotValidWorkspaceException quando il workspace specificato
	 *             non è valido.
	 * @throws FileNotInZipException
	 *             Lancia FileNotInZipException quando il file specificato non è
	 *             all'interno dello zip file.
	 * @throws NotZipFileException
	 *             Lancia NotZipFileException quando il file zip specificato non è
	 *             valido.
	 */
	public Workspace(final String workspaceZipFile)
<span class="fc" id="L60">			throws IOException, NotValidWorkspaceException, FileNotInZipException, NotZipFileException {</span>
		try {
<span class="fc" id="L62">			Zip workspace = new Zip(workspaceZipFile);</span>
<span class="pc bpc" id="L63" title="1 of 4 branches missed.">			if (!workspace.contains(&quot;channels.json&quot;) || !workspace.contains(&quot;users.json&quot;)) {</span>
<span class="fc" id="L64">				throw new NotValidWorkspaceException(workspaceZipFile);</span>
			} else {
<span class="fc" id="L66">				this.workspaceZip = workspace;</span>
<span class="fc" id="L67">				this.channels = new LinkedHashMap&lt;String, Channel&gt;();</span>
<span class="fc" id="L68">				this.members = new LinkedHashMap&lt;String, Member&gt;();</span>
<span class="fc" id="L69">				String realName = &quot;&quot;;</span>
<span class="fc" id="L70">				String displayName = &quot;&quot;;</span>

<span class="fc" id="L72">				JSONArray membersRootArray = new JSONArray(workspaceZip.getFileContent(&quot;users.json&quot;));</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">				for (int i = 0; i &lt; membersRootArray.length(); i++) {</span>
<span class="fc" id="L74">					JSONObject member = membersRootArray.getJSONObject(i);</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">					if (member.getJSONObject(&quot;profile&quot;).has(&quot;real_name&quot;)) {</span>
<span class="fc" id="L76">						realName = member.getJSONObject(&quot;profile&quot;).getString(&quot;real_name&quot;);</span>
					}
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">					if (member.getJSONObject(&quot;profile&quot;).has(&quot;display_name&quot;)) {</span>
<span class="fc" id="L79">						displayName = member.getJSONObject(&quot;profile&quot;).getString(&quot;display_name&quot;);</span>
					}
<span class="fc" id="L81">					Member currMember = new Member(member.getString(&quot;id&quot;), member.getString(&quot;name&quot;), realName,</span>
							displayName);
<span class="fc" id="L83">					members.put(member.getString(&quot;id&quot;), currMember);</span>
				}
<span class="fc" id="L85">				JSONArray channelsRootArray = new JSONArray(workspaceZip.getFileContent(&quot;channels.json&quot;));</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">				for (int j = 0; j &lt; channelsRootArray.length(); j++) {</span>
<span class="fc" id="L87">					JSONObject channel = channelsRootArray.getJSONObject(j);</span>
<span class="fc" id="L88">					Channel currChannel = new Channel(channel.getString(&quot;id&quot;), channel.getString(&quot;name&quot;));</span>
<span class="fc" id="L89">					JSONArray membersArray = channel.getJSONArray(&quot;members&quot;);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">					for (int k = 0; k &lt; membersArray.length(); k++) {</span>
<span class="fc" id="L91">						String memberId = membersArray.getString(k);</span>
<span class="fc" id="L92">						currChannel.getMembers().add(members.get(memberId));</span>
<span class="fc" id="L93">						members.get(memberId).getChannels().add(currChannel);</span>
					}
<span class="fc" id="L95">					channels.put(currChannel.getName(), currChannel);</span>
				}
<span class="fc" id="L97">				Enumeration&lt;? extends ZipEntry&gt; e = workspaceZip.getZipFile().entries();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">				while (e.hasMoreElements()) {</span>
<span class="fc" id="L99">					ZipEntry ze = (ZipEntry) e.nextElement();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">					if (!ze.isDirectory()) {</span>
<span class="fc" id="L101">						String curFileName = ze.getName();</span>
<span class="fc" id="L102">						String currChannel = curFileName.split(&quot;/&quot;)[0];</span>
<span class="fc" id="L103">						Pattern patternDate = Pattern.compile(&quot;([12]\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]))&quot;);</span>
<span class="fc" id="L104">						String channelCont = workspaceZip.getFileContent(curFileName);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">						if (channels.get(currChannel) != null) {</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">							if (patternDate.matcher(curFileName.split(&quot;/&quot;)[1].split(&quot;\\.&quot;)[0]).matches()</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">									&amp;&amp; curFileName.split(&quot;/&quot;)[1].split(&quot;\\.&quot;)[1].equals(&quot;json&quot;)) {</span>
<span class="fc" id="L108">								JSONArray messagesRootArray = new JSONArray(channelCont);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">								for (int i = 0; i &lt; messagesRootArray.length(); i++) {</span>
<span class="fc" id="L110">									JSONObject message = messagesRootArray.getJSONObject(i);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">									if (!message.isNull(&quot;user&quot;)) {</span>
<span class="fc" id="L112">										String currSender = message.getString(&quot;user&quot;);</span>
<span class="fc" id="L113">										String currMessage = message.getString(&quot;text&quot;);</span>
<span class="fc" id="L114">										Pattern pattern = Pattern.compile(&quot;[&lt;@]+(?=.*[0-9])(?=.*[A-Z])([A-Z0-9]+)+[&gt;]&quot;);</span>
<span class="fc" id="L115">										Matcher matcher = pattern.matcher(currMessage);</span>
<span class="fc" id="L116">										List&lt;String&gt; allMatches = new LinkedList&lt;String&gt;();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">										while (matcher.find()) {</span>
<span class="fc" id="L118">											String curr = matcher.group().replaceAll(&quot;&lt;@&quot;, &quot;&quot;).replaceAll(&quot;&gt;&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">											if (members.containsKey(curr)) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">												if (!curr.equals(currSender)) {</span>
<span class="fc" id="L121">													allMatches.add(curr);</span>
												}
											}
<span class="fc" id="L124">										}</span>
<span class="fc" id="L125">										ListIterator&lt;String&gt; it = (ListIterator&lt;String&gt;) allMatches.iterator();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">										while (it.hasNext()) {</span>
<span class="fc" id="L127">											String currReceiver = it.next();</span>
<span class="fc" id="L128">											Mention currMention = new Mention(members.get(currSender),</span>
<span class="fc" id="L129">													members.get(currReceiver));</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">											if (!channels.get(currChannel).containsMention(currMention)) {</span>
<span class="fc" id="L131">												channels.get(currChannel).getMentions().add(currMention);</span>
											} else {
<span class="fc" id="L133">												ListIterator&lt;Mention&gt; mentionIterator = channels.get(currChannel)</span>
<span class="fc" id="L134">														.getMentions().listIterator();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">												while (mentionIterator.hasNext()) {</span>
<span class="fc" id="L136">													Mention curr = mentionIterator.next();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">													if (curr.equals(currMention)) {</span>
<span class="fc" id="L138">														curr.setWeight(curr.getWeight() + 1);</span>
													}
<span class="fc" id="L140">												}</span>
											}
<span class="fc" id="L142">										}</span>
									}
								}
							}
						}
					}
<span class="fc" id="L148">				}</span>

			}
<span class="fc" id="L151">		} catch (ZipException e) {</span>
<span class="fc" id="L152">			throw new NotZipFileException(workspaceZipFile);</span>
<span class="fc" id="L153">		}</span>
<span class="fc" id="L154">	}</span>

	/**
	 * Restituisce la lista di tutti i channels nel workspace corrente.
	 * 
	 * @return riferimento ad una LinkedHashMap&lt;String, Channel&gt; che rappresenta la
	 *         lista di tutti i channels del workspace corrente.
	 */
	public LinkedHashMap&lt;String, Channel&gt; getAllChannels() {
<span class="fc" id="L163">		return (LinkedHashMap&lt;String, Channel&gt;) this.channels;</span>
	}

	/**
	 * Restituisce la lista di tutti i members nel workspce corrente.
	 * 
	 * @return riferimento ad una LinkedHashMap&lt;String, Member&gt; che rappresenta la
	 *         lista di tutti i members del workspace corrente.
	 */
	public LinkedHashMap&lt;String, Member&gt; getAllMembers() {
<span class="fc" id="L173">		return (LinkedHashMap&lt;String, Member&gt;) this.members;</span>
	}

	/**
	 * Restituisce la lista dei members di un determinato channel.
	 * 
	 * @param channelName
	 *            String che rappresenta un determinato channel.
	 * @return riferimento ad una LinkedList&lt;Member&gt; che rappresenta la lista di
	 *         member di un determinato channel.
	 * @throws ChannelNotValidException Lancia un eccezione quando il channel specificato non è valido.
	 */
	public LinkedList&lt;Member&gt; getMembersOfChannel(final String channelName) throws ChannelNotValidException {
<span class="fc bfc" id="L186" title="All 2 branches covered.">		if (channels.containsKey(channelName)) {</span>
<span class="fc" id="L187">			return channels.get(channelName).getMembers();</span>
		} else {
<span class="fc" id="L189">			throw new ChannelNotValidException(channelName);</span>
		}
	}

	/**
	 * Restituisce la lista di mentions fatte da un determinato member in un
	 * determinato channel.
	 * 
	 * @param channelInput
	 *            String che rappresenta un detrminato channel.
	 * @param memberInput
	 *            String che rappresenta un detrminato member.
	 * @return riferimento ad un LinkedList&lt;Mention&gt; che rappresenta la lista di
	 *         mention fatte da un determinato member in un detrminato channel.
	 * @throws ChannelNotValidException Lancia un eccezione quando il channel specificato non è valido.
	 * @throws MemberNotValidException Lancia un eccezione quando il member specificato non è valido.
	 */
	public LinkedList&lt;Mention&gt; getMentionsFromUser(final String channelInput, final String memberInput)
			throws ChannelNotValidException, MemberNotValidException {
<span class="fc" id="L208">		String memberID = memberInput;</span>
<span class="fc" id="L209">		Collection&lt;Member&gt; membersCollection = members.values();</span>
<span class="fc" id="L210">		Iterator&lt;Member&gt; membersIterator = membersCollection.iterator();</span>
<span class="fc" id="L211">		boolean found = false;</span>
<span class="fc bfc" id="L212" title="All 4 branches covered.">		while (membersIterator.hasNext() &amp;&amp; !found) {</span>
<span class="fc" id="L213">			Member currMember = membersIterator.next();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">			if (currMember.isUser(memberID)) {</span>
<span class="fc" id="L215">				memberID = currMember.getId();</span>
<span class="fc" id="L216">				found = true;</span>
			}
<span class="fc" id="L218">		}</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">		if (found) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">			if (channels.containsKey(channelInput)) {</span>
<span class="fc" id="L221">				LinkedList&lt;Mention&gt; out = new LinkedList&lt;Mention&gt;();</span>
<span class="fc" id="L222">				LinkedList&lt;Mention&gt; mentions = channels.get(channelInput).getMentions();</span>
<span class="fc" id="L223">				ListIterator&lt;Mention&gt; it = (ListIterator&lt;Mention&gt;) mentions.iterator();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">				while (it.hasNext()) {</span>
<span class="fc" id="L225">					Mention curMention = it.next();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">					if (curMention.getFrom().equals(members.get(memberID))) {</span>
<span class="fc" id="L227">						out.add(curMention);</span>
					}
<span class="fc" id="L229">				}</span>
<span class="fc" id="L230">				return out;</span>
			} else {
<span class="fc" id="L232">				throw new ChannelNotValidException(channelInput);</span>
			}
		} else {
<span class="fc" id="L235">			throw new MemberNotValidException(memberID);</span>
		}

	}

	/**
	 * Restituisce le mention riferite ad uno specifico member in uno specifico
	 * channel.
	 * 
	 * @param channelInput
	 *            String che rappresenta un detrminatro channel.
	 * @param memberInput
	 *            String che rappresenta un determinato member.
	 * @return riferimento ad un LinkedList&lt;Mention&gt; che rappresenta la lista di
	 *         mention fatte in uno specifico channel ad un particolare member.
	 * @throws ChannelNotValidException Lancia un eccezione quando il channel specificato non è valido.
	 * @throws MemberNotValidException Lancia un eccezione quando il member specificato non è valido.
	 */
	public LinkedList&lt;Mention&gt; getMentionsToUser(final String channelInput, final String memberInput)
			throws ChannelNotValidException, MemberNotValidException {
<span class="fc" id="L255">		String memberID = memberInput;</span>
<span class="fc" id="L256">		Collection&lt;Member&gt; membersCollection = members.values();</span>
<span class="fc" id="L257">		Iterator&lt;Member&gt; membersIterator = membersCollection.iterator();</span>
<span class="fc" id="L258">		boolean found = false;</span>
<span class="fc bfc" id="L259" title="All 4 branches covered.">		while (membersIterator.hasNext() &amp;&amp; !found) {</span>
<span class="fc" id="L260">			Member currMember = membersIterator.next();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">			if (currMember.isUser(memberID)) {</span>
<span class="fc" id="L262">				memberID = currMember.getId();</span>
<span class="fc" id="L263">				found = true;</span>
			}
<span class="fc" id="L265">		}</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">		if (found) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">			if (channels.containsKey(channelInput)) {</span>
<span class="fc" id="L268">				LinkedList&lt;Mention&gt; out = new LinkedList&lt;Mention&gt;();</span>
<span class="fc" id="L269">				LinkedList&lt;Mention&gt; mentions = channels.get(channelInput).getMentions();</span>
<span class="fc" id="L270">				ListIterator&lt;Mention&gt; it = (ListIterator&lt;Mention&gt;) mentions.iterator();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				while (it.hasNext()) {</span>
<span class="fc" id="L272">					Mention curMention = it.next();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">					if (curMention.getTo().equals(members.get(memberID))) {</span>
<span class="fc" id="L274">						out.add(curMention);</span>
					}
<span class="fc" id="L276">				}</span>
<span class="fc" id="L277">				return out;</span>
			} else {
<span class="fc" id="L279">				throw new ChannelNotValidException(channelInput);</span>
			}
		} else {
<span class="fc" id="L282">			throw new MemberNotValidException(memberID);</span>
		}
	}

	/**
	 * Restituisce la lista di mention fatte in un determinato channel.
	 * 
	 * @param channelName
	 *            String che rappresenta un detrminatro channel.
	 * @return riferimento ad un LinkedList&lt;Mention&gt; che rappresenta la lista di
	 *         mention fatte in un determinato channel.
	 * @throws ChannelNotValidException Lancia un eccezione quando il channel specificato non è valido.
	 */
	public LinkedList&lt;Mention&gt; getMentions(final String channelName) throws ChannelNotValidException {
<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (channels.containsKey(channelName)) {</span>
<span class="fc" id="L297">			return channels.get(channelName).getMentions();</span>
		} else {
<span class="fc" id="L299">			throw new ChannelNotValidException(channelName);</span>
		}
	}

	/**
	 * Restituisce il riferimento all'attributo workspaceZip della classe.
	 * 
	 * @return riferimento ad un oggetto istanza della classe zip che rappresenta il
	 *         workspace corrente.
	 */
	public Zip getWorkspaceZip() {
<span class="fc" id="L310">		return workspaceZip;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>