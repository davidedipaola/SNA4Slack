<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommandManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SNA4Slack</a> &gt; <a href="index.source.html" class="el_package">it.uniba.cli</a> &gt; <span class="el_source">CommandManager.java</span></div><h1>CommandManager.java</h1><pre class="source lang-java linenums">package it.uniba.cli;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.ListIterator;
import it.uniba.entity.Channel;
import it.uniba.entity.ChannelNotValidException;
import it.uniba.entity.Member;
import it.uniba.entity.MemberNotValidException;
import it.uniba.entity.Mention;
import it.uniba.entity.Workspace;
import it.uniba.file.PathManager;
import it.uniba.file.zip.FileNotInZipException;
import it.uniba.file.zip.NotValidWorkspaceException;
import it.uniba.file.zip.NotZipFileException;

/**
 * Classe che contiene l'implementazione dei possibili comandi.
 */
public final class CommandManager {
	/**
	 * Attributo di classe che rappresenta la stringa di errore di un comando non
	 * valido.
	 */
	public static final String NOTVALIDCOMMAND = &quot; is not a valid command, see 'help'.&quot;;
	/**
	 * Attributo di classe che rappresenta la stringa del comando mentions.
	 */
	public static final String MENTIONSCOMMAND = &quot;mentions&quot;;
	/**
	 * Attributo di classe che rappresenta la stringa del parametro -ch.
	 */
	public static final String CHPARAMETER = &quot;-ch&quot;;
	/**
	 * Attributo di classe che rappresenta la stringa del parametro -from.
	 */
	public static final String FROMPARAMETER = &quot;-from&quot;;
	/**
	 * Attributo di classe che rappresenta la stringa del parametro -ch.
	 */
	public static final String TOPARAMETER = &quot;-to&quot;;
	/**
	 * Attributo di classe che rappresenta la stringa &quot;not found&quot;.
	 */
	private static final String NOTFOUND = &quot; not found&quot;;
	/**
	 * Attributo di classe che rappresenta il valore 0.
	 */
	private static final int ZERO = 0;
	/**
	 * Attributo di classe che rappresenta il valore 1.
	 */
	private static final int ONE = 1;
	/**
	 * Attributo di classe che rappresenta il valore 2.
	 */
	private static final int TWO = 2;
	/**
	 * Attributo di classe che rappresenta il valore 3.
	 */
	private static final int THREE = 3;
	/**
	 * Attributo di classe che rappresenta il valore 4.
	 */
	private static final int FOUR = 4;
	/**
	 * Attributo di classe che rappresenta il valore 5.
	 */
	private static final int FIVE = 5;
	/**
	 * Attributo di classe che rappresenta il valore 6.
	 */
	private static final int SIX = 6;
	/**
	 * Attributo di classe che rappresenta il valore 7.
	 */
	private static final int SEVEN = 7;
	/**
	 * Attributo di classe che rappresenta il valore 8.
	 */
	private static final int EIGHT = 8;

	/**
	 * Metodo costruttore della classe CommandManager, permette di costruire oggetti
	 * istanze della classe CommandManager.
	 */
	private CommandManager() {
	}

	/**
	 * Scrive sullo standard output stream la lista di tutti i possibili comandi.
	 */
	public static void help() {
<span class="fc" id="L99">		final Commands commands = new Commands();</span>
<span class="fc" id="L100">		int maxNumCharCommand = ZERO;</span>
<span class="fc" id="L101">		int maxNCharDesc = ZERO;</span>
<span class="fc" id="L102">		final LinkedList&lt;Command&gt; commandList = (LinkedList&lt;Command&gt;) commands.getCommands();</span>
<span class="fc" id="L103">		ListIterator&lt;Command&gt; commandsIterator = (ListIterator&lt;Command&gt;) commandList.iterator();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">		while (commandsIterator.hasNext()) {</span>
<span class="fc" id="L105">			final Command curr = commandsIterator.next();</span>
<span class="fc" id="L106">			final int currCommLength = (curr.getName() + &quot; &quot; + curr.getOptions()).length();</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">			if (currCommLength &gt;= maxNumCharCommand) {</span>
<span class="fc" id="L108">				maxNumCharCommand = currCommLength;</span>
			}
<span class="fc" id="L110">			final int currDescLength = curr.getDescription().length();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			if (currDescLength &gt;= maxNCharDesc) {</span>
<span class="fc" id="L112">				maxNCharDesc = currDescLength;</span>
			}
<span class="fc" id="L114">		}</span>
<span class="fc" id="L115">		System.out.format(&quot;%&quot; + maxNumCharCommand + &quot;s\t%&quot; + maxNCharDesc + &quot;s&quot;, &quot;COMMAND&quot;, &quot;DESCRIPTION&quot;);</span>
<span class="fc" id="L116">		System.out.println();</span>
<span class="fc" id="L117">		System.out.println();</span>
<span class="fc" id="L118">		commandsIterator = (ListIterator&lt;Command&gt;) commandList.iterator();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		while (commandsIterator.hasNext()) {</span>
<span class="fc" id="L120">			final Command curr = commandsIterator.next();</span>
<span class="fc" id="L121">			System.out.format(&quot;%&quot; + maxNumCharCommand + &quot;s\t%&quot; + maxNCharDesc + &quot;s&quot;,</span>
<span class="fc" id="L122">					curr.getName() + &quot; &quot; + curr.getOptions(), curr.getDescription());</span>
<span class="fc" id="L123">			System.out.println();</span>
<span class="fc" id="L124">		}</span>
<span class="fc" id="L125">	}</span>

	/**
	 * Scrive sullo standard output stream tutti i channels presenti nel workspace
	 * passatogli in input.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 */
	public static void getChannels(final String workspace) {
		try {
<span class="fc" id="L136">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L137">			final LinkedHashMap&lt;String, Channel&gt; workspaceChannels = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L138">					.getAllChannels();</span>
<span class="fc" id="L139">			final Collection&lt;Channel&gt; channels = workspaceChannels.values();</span>
<span class="fc" id="L140">			final Iterator&lt;Channel&gt; channelsIterator = channels.iterator();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L142">				final Channel currChannel = channelsIterator.next();</span>
<span class="fc" id="L143">				System.out.println(currChannel.getName());</span>
<span class="fc" id="L144">			}</span>
<span class="fc" id="L145">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L146">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L147">		} catch (IOException e) {</span>
<span class="nc" id="L148">			e.printStackTrace();</span>
<span class="fc" id="L149">		} catch (FileNotInZipException | NotValidWorkspaceException | NotZipFileException e) {</span>
<span class="fc" id="L150">			System.out.println(e.getMessage());</span>
<span class="pc" id="L151">		}</span>
<span class="fc" id="L152">	}</span>

	/**
	 * Scrive sullo standard output stream tutti i members presenti nel workspace
	 * pasatogli in input.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 */
	public static void getMembers(final String workspace) {
		try {
<span class="fc" id="L163">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L164">			final LinkedHashMap&lt;String, Member&gt; workspaceMembers = (LinkedHashMap&lt;String, Member&gt;) slackWorkspace</span>
<span class="fc" id="L165">					.getAllMembers();</span>
<span class="fc" id="L166">			final Collection&lt;Member&gt; members = workspaceMembers.values();</span>
<span class="fc" id="L167">			final Iterator&lt;Member&gt; membersIterator = members.iterator();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">			while (membersIterator.hasNext()) {</span>
<span class="fc" id="L169">				final Member currMember = membersIterator.next();</span>
<span class="fc" id="L170">				System.out.println(currMember.getName());</span>
<span class="fc" id="L171">			}</span>
<span class="fc" id="L172">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L173">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L174">		} catch (IOException e) {</span>
<span class="nc" id="L175">			e.printStackTrace();</span>
<span class="fc" id="L176">		} catch (FileNotInZipException | NotValidWorkspaceException | NotZipFileException e) {</span>
<span class="fc" id="L177">			System.out.println(e.getMessage());</span>

<span class="pc" id="L179">		}</span>
<span class="fc" id="L180">	}</span>

	/**
	 * Scrive sullo standard output stream tutti i members di uno specifico channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono ottenere i
	 *            Members.
	 */
	public static void getMembersOfChannel(final String workspace, final String channel) {
		try {
<span class="fc" id="L193">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L194">			final LinkedList&lt;Member&gt; channelMembers = (LinkedList&lt;Member&gt;) slackWorkspace.getMembersOfChannel(channel);</span>
<span class="fc" id="L195">			final ListIterator&lt;Member&gt; membersIterator = (ListIterator&lt;Member&gt;) channelMembers.iterator();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			while (membersIterator.hasNext()) {</span>
<span class="fc" id="L197">				final Member currMember = membersIterator.next();</span>
<span class="fc" id="L198">				System.out.println(currMember.getName());</span>
<span class="fc" id="L199">			}</span>
<span class="fc" id="L200">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L201">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L202">		} catch (IOException e) {</span>
<span class="nc" id="L203">			e.printStackTrace();</span>
<span class="fc" id="L204">		} catch (ChannelNotValidException | FileNotInZipException | NotValidWorkspaceException</span>
				| NotZipFileException e) {
<span class="fc" id="L206">			System.out.println(e.getMessage());</span>
<span class="pc" id="L207">		}</span>
<span class="fc" id="L208">	}</span>

	/**
	 * Scrive sullo standard output stream tutti i member raggruppati per channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 */
	public static void getMembersForChannels(final String workspace) {
		try {
<span class="fc" id="L218">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L219">			final LinkedHashMap&lt;String, Channel&gt; workspaceChannels = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L220">					.getAllChannels();</span>
<span class="fc" id="L221">			final Collection&lt;Channel&gt; channels = workspaceChannels.values();</span>
<span class="fc" id="L222">			final Iterator&lt;Channel&gt; channelsIterator = channels.iterator();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L224">				final Channel currChannel = channelsIterator.next();</span>
<span class="fc" id="L225">				final LinkedList&lt;Member&gt; channelMembers = (LinkedList&lt;Member&gt;) slackWorkspace</span>
<span class="fc" id="L226">						.getMembersOfChannel(currChannel.getName());</span>
<span class="fc" id="L227">				final ListIterator&lt;Member&gt; membersIterator = (ListIterator&lt;Member&gt;) channelMembers.iterator();</span>
<span class="fc" id="L228">				System.out.println(&quot;Members of \&quot;&quot; + currChannel.getName() + &quot;\&quot;:&quot;);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">				while (membersIterator.hasNext()) {</span>
<span class="fc" id="L230">					final Member currMember = membersIterator.next();</span>
<span class="fc" id="L231">					System.out.println(&quot;\t&quot; + currMember.getName());</span>
<span class="fc" id="L232">				}</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">				if (channelsIterator.hasNext()) {</span>
<span class="fc" id="L234">					System.out.println();</span>
				}
<span class="fc" id="L236">			}</span>
<span class="fc" id="L237">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L238">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L239">		} catch (IOException e) {</span>
<span class="nc" id="L240">			e.printStackTrace();</span>
<span class="fc" id="L241">		} catch (FileNotInZipException | NotValidWorkspaceException | NotZipFileException e) {</span>
<span class="fc" id="L242">			System.out.println(e.getMessage());</span>
<span class="nc" id="L243">		} catch (ChannelNotValidException e) {</span>
<span class="nc" id="L244">			e.printStackTrace();</span>
<span class="pc" id="L245">		}</span>
<span class="fc" id="L246">	}</span>

	/**
	 * Scrive sullo standard output stream tutte le mentions effettuate da uno
	 * specifico member.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsFromUser(final String workspace, final String member) {
		try {
<span class="fc" id="L260">			final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
<span class="fc" id="L261">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L262">			final LinkedHashMap&lt;String, Channel&gt; chList = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L263">					.getAllChannels();</span>
<span class="fc" id="L264">			final Collection&lt;Channel&gt; chCollection = chList.values();</span>
<span class="fc" id="L265">			final Iterator&lt;Channel&gt; channelsIeretor = chCollection.iterator();</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">			while (channelsIeretor.hasNext()) {</span>
<span class="fc" id="L267">				final Channel currChannel = channelsIeretor.next();</span>
<span class="fc" id="L268">				final LinkedList&lt;Mention&gt; currChMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L269">						.getMentionsFromUser(currChannel.getName(), member);</span>
<span class="fc" id="L270">				final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) currChMentions.iterator();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L272">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L273">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">					if (!out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L275">						out.put(currMentionKey, currMention);</span>
<span class="fc" id="L276">						System.out.println(currMention);</span>
					}
<span class="fc" id="L278">				}</span>
<span class="fc" id="L279">			}</span>
<span class="fc" id="L280">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L281">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L282">		} catch (IOException | ChannelNotValidException e) {</span>
<span class="nc" id="L283">			e.printStackTrace();</span>
<span class="fc" id="L284">		} catch (MemberNotValidException | NotValidWorkspaceException | FileNotInZipException | NotZipFileException e) {</span>
<span class="fc" id="L285">			System.out.println(e.getMessage());</span>
<span class="pc" id="L286">		}</span>
<span class="fc" id="L287">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di mentions effettuate da
	 * uno specifico member.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsFromUserWeighed(final String workspace, final String member) {
		try {
<span class="fc" id="L301">			final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
<span class="fc" id="L302">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L303">			final LinkedHashMap&lt;String, Channel&gt; channelList = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L304">					.getAllChannels();</span>
<span class="fc" id="L305">			final Collection&lt;Channel&gt; chCollection = channelList.values();</span>
<span class="fc" id="L306">			final Iterator&lt;Channel&gt; channelsIeretor = chCollection.iterator();</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">			while (channelsIeretor.hasNext()) {</span>
<span class="fc" id="L308">				final Channel curChannel = channelsIeretor.next();</span>
<span class="fc" id="L309">				final LinkedList&lt;Mention&gt; currChMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L310">						.getMentionsFromUser(curChannel.getName(), member);</span>
<span class="fc" id="L311">				final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) currChMentions.iterator();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L313">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L314">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">					if (out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L316">						final Mention outMent = out.get(currMentionKey);</span>
<span class="fc" id="L317">						outMent.setWeight(outMent.getWeight() + currMention.getWeight());</span>
<span class="fc" id="L318">					} else {</span>
<span class="fc" id="L319">						out.put(currMentionKey, currMention);</span>
					}
<span class="fc" id="L321">				}</span>
<span class="fc" id="L322">			}</span>
<span class="fc" id="L323">			final Collection&lt;Mention&gt; mentColl = out.values();</span>
<span class="fc" id="L324">			final Iterator&lt;Mention&gt; outIterator = mentColl.iterator();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">			while (outIterator.hasNext()) {</span>
<span class="fc" id="L326">				final Mention currMent = outIterator.next();</span>
<span class="fc" id="L327">				System.out.println(currMent.toFullString());</span>
<span class="fc" id="L328">			}</span>
<span class="fc" id="L329">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L330">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L331">		} catch (IOException | ChannelNotValidException e) {</span>
<span class="nc" id="L332">			e.printStackTrace();</span>
<span class="fc" id="L333">		} catch (MemberNotValidException | NotValidWorkspaceException | FileNotInZipException | NotZipFileException e) {</span>
<span class="fc" id="L334">			System.out.println(e.getMessage());</span>
<span class="pc" id="L335">		}</span>
<span class="fc" id="L336">	}</span>

	/**
	 * Scrive sullo standard output stream la lista di mentions effettuate da uno
	 * specifico member in un determinato channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono conoscere le
	 *            mention.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsFromUser(final String workspace, final String channel, final String member) {
		try {
<span class="fc" id="L353">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L354">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L355">					.getMentionsFromUser(channel, member);</span>
<span class="fc" id="L356">			final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) workspaceMentions.iterator();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L358">				System.out.println(mentionsIterator.next());</span>
			}
<span class="fc" id="L360">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L361">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L362">		} catch (IOException e) {</span>
<span class="nc" id="L363">			e.printStackTrace();</span>
<span class="fc" id="L364">		} catch (ChannelNotValidException | MemberNotValidException | NotValidWorkspaceException | FileNotInZipException</span>
				| NotZipFileException e) {
<span class="fc" id="L366">			System.out.println(e.getMessage());</span>
<span class="pc" id="L367">		}</span>
<span class="fc" id="L368">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di mentions effettuate da
	 * uno specifico member in un determinato channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono conoscere le
	 *            mention.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsFromUserWeighed(final String workspace, final String channel, final String member) {
		try {
<span class="fc" id="L385">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L386">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L387">					.getMentionsFromUser(channel, member);</span>
<span class="fc" id="L388">			final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) workspaceMentions.iterator();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L390">				final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L391">				System.out.println(currMention.toFullString());</span>
<span class="fc" id="L392">			}</span>
<span class="fc" id="L393">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L394">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L395">		} catch (IOException e) {</span>
<span class="nc" id="L396">			e.printStackTrace();</span>
<span class="fc" id="L397">		} catch (ChannelNotValidException | MemberNotValidException | NotValidWorkspaceException | FileNotInZipException</span>
				| NotZipFileException e) {
<span class="fc" id="L399">			System.out.println(e.getMessage());</span>
<span class="pc" id="L400">		}</span>
<span class="fc" id="L401">	}</span>

	/**
	 * Scrive sullo standard output stream la lista di mentions riferite ad uno
	 * specifico member.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsToUser(final String workspace, final String member) {
		try {
<span class="fc" id="L415">			final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
<span class="fc" id="L416">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L417">			final LinkedHashMap&lt;String, Channel&gt; channelMap = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L418">					.getAllChannels();</span>
<span class="fc" id="L419">			final Collection&lt;Channel&gt; chCollection = channelMap.values();</span>
<span class="fc" id="L420">			final Iterator&lt;Channel&gt; channelsIterator = chCollection.iterator();</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L422">				final Channel currChannel = channelsIterator.next();</span>
<span class="fc" id="L423">				final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L424">						.getMentionsToUser(currChannel.getName(), member);</span>
<span class="fc" id="L425">				final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) workspaceMentions.iterator();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L427">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L428">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">					if (!out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L430">						out.put(currMentionKey, currMention);</span>
<span class="fc" id="L431">						System.out.println(currMention);</span>
					}
<span class="fc" id="L433">				}</span>
<span class="fc" id="L434">			}</span>
<span class="fc" id="L435">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L436">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L437">		} catch (IOException | ChannelNotValidException e) {</span>
<span class="nc" id="L438">			e.printStackTrace();</span>
<span class="fc" id="L439">		} catch (MemberNotValidException | NotValidWorkspaceException | FileNotInZipException | NotZipFileException e) {</span>
<span class="fc" id="L440">			System.out.println(e.getMessage());</span>
<span class="pc" id="L441">		}</span>
<span class="fc" id="L442">	}</span>

	/**
	 * Scrive sullo standard output stream la lista di mentions riferite ad uno
	 * specifico member in un determinato channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono conoscere le
	 *            mention.
	 * @param member
	 *            String che rappresenta il member di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsToUser(final String workspace, final String channel, final String member) {
		try {
<span class="fc" id="L459">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L460">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L461">					.getMentionsToUser(channel, member);</span>
<span class="fc" id="L462">			final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) workspaceMentions.iterator();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L464">				System.out.println(mentionsIterator.next());</span>
			}
<span class="fc" id="L466">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L467">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L468">		} catch (IOException e) {</span>
<span class="nc" id="L469">			e.printStackTrace();</span>
<span class="fc" id="L470">		} catch (ChannelNotValidException | MemberNotValidException | NotValidWorkspaceException | FileNotInZipException</span>
				| NotZipFileException e) {
<span class="fc" id="L472">			System.out.println(e.getMessage());</span>
<span class="pc" id="L473">		}</span>
<span class="fc" id="L474">	}</span>

	/**
	 * Scrive sullo standard output stream la lista di mentions in un determinato
	 * channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono conoscere lee
	 *            mention.
	 */
	public static void getMentions(final String workspace, final String channel) {
		try {
<span class="fc" id="L488">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L489">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace.getMentions(channel);</span>
<span class="fc" id="L490">			final Iterator&lt;Mention&gt; mentionsIterator = workspaceMentions.iterator();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L492">				System.out.println(mentionsIterator.next());</span>
			}
<span class="fc" id="L494">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L495">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L496">		} catch (IOException e) {</span>
<span class="nc" id="L497">			e.printStackTrace();</span>
<span class="fc" id="L498">		} catch (ChannelNotValidException | FileNotInZipException | NotValidWorkspaceException</span>
				| NotZipFileException e) {
<span class="fc" id="L500">			System.out.println(e.getMessage());</span>
<span class="pc" id="L501">		}</span>
<span class="fc" id="L502">	}</span>

	/**
	 * Scrive sullo standard output stream la lista di tutte le mentions.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 */
	public static void getMentions(final String workspace) {
		try {
<span class="fc" id="L512">			final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
<span class="fc" id="L513">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L514">			final LinkedHashMap&lt;String, Channel&gt; channelMap = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L515">					.getAllChannels();</span>
<span class="fc" id="L516">			final Collection&lt;Channel&gt; chCollection = channelMap.values();</span>
<span class="fc" id="L517">			final Iterator&lt;Channel&gt; channelsIterator = chCollection.iterator();</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L519">				final Channel currchannel = channelsIterator.next();</span>
<span class="fc" id="L520">				final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L521">						.getMentions(currchannel.getName());</span>
<span class="fc" id="L522">				final Iterator&lt;Mention&gt; mentionsIterator = workspaceMentions.iterator();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L524">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L525">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">					if (!out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L527">						out.put(currMentionKey, currMention);</span>
<span class="fc" id="L528">						System.out.println(currMention);</span>
					}
<span class="fc" id="L530">				}</span>
<span class="fc" id="L531">			}</span>
<span class="fc" id="L532">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L533">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L534">		} catch (IOException e) {</span>
<span class="nc" id="L535">			e.printStackTrace();</span>
<span class="fc" id="L536">		} catch (FileNotInZipException | NotValidWorkspaceException | NotZipFileException e) {</span>
<span class="fc" id="L537">			System.out.println(e.getMessage());</span>
<span class="nc" id="L538">		} catch (ChannelNotValidException e) {</span>
<span class="nc" id="L539">			e.printStackTrace();</span>
<span class="pc" id="L540">		}</span>
<span class="fc" id="L541">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di tutte le mentions.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 */
	public static void getMentionsWeighed(final String workspace) {
<span class="fc" id="L550">		final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
		try {
<span class="fc" id="L552">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L553">			final LinkedHashMap&lt;String, Channel&gt; channelMap = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L554">					.getAllChannels();</span>
<span class="fc" id="L555">			final Collection&lt;Channel&gt; chCollection = channelMap.values();</span>
<span class="fc" id="L556">			final Iterator&lt;Channel&gt; channelsIterator = chCollection.iterator();</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L558">				final Channel currChannel = channelsIterator.next();</span>
<span class="fc" id="L559">				final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L560">						.getMentions(currChannel.getName());</span>
<span class="fc" id="L561">				final Iterator&lt;Mention&gt; mentionsIterator = workspaceMentions.iterator();</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L563">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L564">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">					if (out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L566">						final Mention outMent = out.get(currMentionKey);</span>
<span class="fc" id="L567">						outMent.setWeight(currMention.getWeight() + outMent.getWeight());</span>
<span class="fc" id="L568">					} else {</span>
<span class="fc" id="L569">						out.put(currMentionKey, currMention);</span>
					}
<span class="fc" id="L571">				}</span>
<span class="fc" id="L572">			}</span>
<span class="fc" id="L573">			final Collection&lt;Mention&gt; mentionColl = out.values();</span>
<span class="fc" id="L574">			final Iterator&lt;Mention&gt; outIterator = mentionColl.iterator();</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">			while (outIterator.hasNext()) {</span>
<span class="fc" id="L576">				final Mention currMention = outIterator.next();</span>
<span class="fc" id="L577">				System.out.println(currMention.toFullString());</span>
<span class="fc" id="L578">			}</span>
<span class="fc" id="L579">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L580">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L581">		} catch (IOException e) {</span>
<span class="nc" id="L582">			e.printStackTrace();</span>
<span class="fc" id="L583">		} catch (FileNotInZipException | NotValidWorkspaceException | NotZipFileException e) {</span>
<span class="fc" id="L584">			System.out.println(e.getMessage());</span>
<span class="nc" id="L585">		} catch (ChannelNotValidException e) {</span>
<span class="nc" id="L586">			e.printStackTrace();</span>
<span class="pc" id="L587">		}</span>
<span class="fc" id="L588">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di tutte le mentions
	 * prenti in un determinato channel.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta il channel di cui si vogliono conoscere le
	 *            mention.
	 */
	public static void getMentionsWeighed(final String workspace, final String channel) {
<span class="fc" id="L601">		final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
		try {
<span class="fc" id="L603">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L604">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace.getMentions(channel);</span>
<span class="fc" id="L605">			final Iterator&lt;Mention&gt; mentionsIterator = workspaceMentions.iterator();</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L607">				final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L608">				final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc" id="L609">				out.put(currMentionKey, currMention);</span>
<span class="fc" id="L610">			}</span>
<span class="fc" id="L611">			final Collection&lt;Mention&gt; mentionColl = out.values();</span>
<span class="fc" id="L612">			final Iterator&lt;Mention&gt; outIterator = mentionColl.iterator();</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">			while (outIterator.hasNext()) {</span>
<span class="fc" id="L614">				final Mention currMention = outIterator.next();</span>
<span class="fc" id="L615">				System.out.println(currMention.toFullString());</span>
<span class="fc" id="L616">			}</span>
<span class="fc" id="L617">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L618">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L619">		} catch (IOException e) {</span>
<span class="nc" id="L620">			e.printStackTrace();</span>
<span class="fc" id="L621">		} catch (ChannelNotValidException | FileNotInZipException | NotValidWorkspaceException</span>
				| NotZipFileException e) {
<span class="fc" id="L623">			System.out.println(e.getMessage());</span>
<span class="pc" id="L624">		}</span>
<span class="fc" id="L625">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di tutte le mentios
	 * riferite ad un particolare member.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param member
	 *            String che rappresenta un particolare member di cui si vogliono
	 *            conoscere le mention.
	 */
	public static void getMentionsToUserWeighed(final String workspace, final String member) {
		try {
<span class="fc" id="L639">			final LinkedHashMap&lt;String, Mention&gt; out = new LinkedHashMap&lt;String, Mention&gt;();</span>
<span class="fc" id="L640">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L641">			final LinkedHashMap&lt;String, Channel&gt; channelMap = (LinkedHashMap&lt;String, Channel&gt;) slackWorkspace</span>
<span class="fc" id="L642">					.getAllChannels();</span>
<span class="fc" id="L643">			final Collection&lt;Channel&gt; chCollection = channelMap.values();</span>
<span class="fc" id="L644">			final Iterator&lt;Channel&gt; channelsIterator = chCollection.iterator();</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">			while (channelsIterator.hasNext()) {</span>
<span class="fc" id="L646">				final Channel currChannel = channelsIterator.next();</span>
<span class="fc" id="L647">				final LinkedList&lt;Mention&gt; currChMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L648">						.getMentionsToUser(currChannel.getName(), member);</span>
<span class="fc" id="L649">				final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) currChMentions.iterator();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">				while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L651">					final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L652">					final String currMentionKey = currMention.getFromId() + &quot;,&quot; + currMention.getToId();</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">					if (out.containsKey(currMentionKey)) {</span>
<span class="fc" id="L654">						final Mention outMent = out.get(currMentionKey);</span>
<span class="fc" id="L655">						outMent.setWeight(outMent.getWeight() + currMention.getWeight());</span>
<span class="fc" id="L656">					} else {</span>
<span class="fc" id="L657">						out.put(currMentionKey, currMention);</span>
					}
<span class="fc" id="L659">				}</span>
<span class="fc" id="L660">			}</span>
<span class="fc" id="L661">			final Collection&lt;Mention&gt; mentionColl = out.values();</span>
<span class="fc" id="L662">			final Iterator&lt;Mention&gt; outIterator = mentionColl.iterator();</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">			while (outIterator.hasNext()) {</span>
<span class="fc" id="L664">				final Mention currMent = outIterator.next();</span>
<span class="fc" id="L665">				System.out.println(currMent.toFullString());</span>
<span class="fc" id="L666">			}</span>
<span class="fc" id="L667">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L668">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L669">		} catch (IOException | ChannelNotValidException e) {</span>
<span class="nc" id="L670">			e.printStackTrace();</span>
<span class="fc" id="L671">		} catch (MemberNotValidException | NotValidWorkspaceException | FileNotInZipException | NotZipFileException e) {</span>
<span class="fc" id="L672">			System.out.println(e.getMessage());</span>
<span class="pc" id="L673">		}</span>
<span class="fc" id="L674">	}</span>

	/**
	 * Scrive sullo standard output stream la lista pesata di tutte le mentions
	 * prenti in un determinato channel riferite ad un detereminato member.
	 * 
	 * @param workspace
	 *            String che rappresenta il percorso del workspace.
	 * @param channel
	 *            String che rappresenta un particolare channel di cui si vogliono
	 *            conoscere le mention.
	 * @param member
	 *            String che rappresenta un particolare member di cui si vogliono
	 *            conoscere le mention.
	 */
	public static void getMentionsToUserWeighed(final String workspace, final String channel, final String member) {
		try {
<span class="fc" id="L691">			final Workspace slackWorkspace = new Workspace(PathManager.getAbsolutePath(workspace));</span>
<span class="fc" id="L692">			final LinkedList&lt;Mention&gt; workspaceMentions = (LinkedList&lt;Mention&gt;) slackWorkspace</span>
<span class="fc" id="L693">					.getMentionsToUser(channel, member);</span>
<span class="fc" id="L694">			final ListIterator&lt;Mention&gt; mentionsIterator = (ListIterator&lt;Mention&gt;) workspaceMentions.iterator();</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">			while (mentionsIterator.hasNext()) {</span>
<span class="fc" id="L696">				final Mention currMention = mentionsIterator.next();</span>
<span class="fc" id="L697">				System.out.println(currMention.toFullString());</span>
<span class="fc" id="L698">			}</span>
<span class="fc" id="L699">		} catch (FileNotFoundException | NoSuchFileException e) {</span>
<span class="fc" id="L700">			System.out.println(PathManager.getAbsolutePath(workspace) + NOTFOUND);</span>
<span class="nc" id="L701">		} catch (IOException e) {</span>
<span class="nc" id="L702">			e.printStackTrace();</span>
<span class="fc" id="L703">		} catch (ChannelNotValidException | MemberNotValidException | NotValidWorkspaceException | FileNotInZipException</span>
				| NotZipFileException e) {
<span class="fc" id="L705">			System.out.println(e.getMessage());</span>
<span class="pc" id="L706">		}</span>
<span class="fc" id="L707">	}</span>

	/**
	 * Permette di richiamare il giusto metodo associato al comando specificato
	 * dall'utente attraverso la riga di comando.
	 * 
	 * @param args
	 *            array di String ciascuno dei quali contiene un singolo elemento
	 *            del comando digitato dall'utente da riga di comando.
	 */
	public static void manage(final String... args) {
		final String first, second, third, fourth, fifth, sixth, seventh, eighth;
<span class="fc bfc" id="L719" title="All 10 branches covered.">		switch (args.length) {</span>
		case ZERO:
<span class="fc" id="L721">			help();</span>
<span class="fc" id="L722">			break;</span>
		case ONE:
<span class="fc" id="L724">			first = args[ZERO];</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">			if (&quot;help&quot;.equals(first)) {</span>
<span class="fc" id="L726">				help();</span>
			} else {
<span class="fc" id="L728">				System.out.println(&quot;'&quot; + first + &quot;'&quot; + NOTVALIDCOMMAND);</span>
			}
<span class="fc" id="L730">			break;</span>
		case TWO:
<span class="fc" id="L732">			first = args[ZERO];</span>
<span class="fc" id="L733">			second = args[ONE];</span>
<span class="fc" id="L734">			System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot;'&quot; + NOTVALIDCOMMAND);</span>
<span class="fc" id="L735">			break;</span>
		case THREE:
<span class="fc" id="L737">			first = args[ZERO];</span>
<span class="fc" id="L738">			second = args[ONE];</span>
<span class="fc" id="L739">			third = args[TWO];</span>
<span class="pc bpc" id="L740" title="1 of 4 branches missed.">			if (&quot;members&quot;.equals(first) &amp;&amp; &quot;-f&quot;.equals(second)) {</span>
<span class="fc" id="L741">				getMembers(third);</span>
<span class="pc bpc" id="L742" title="1 of 4 branches missed.">			} else if (&quot;channels&quot;.equals(first) &amp;&amp; &quot;-f&quot;.equals(second)) {</span>
<span class="fc" id="L743">				getChannels(third);</span>
<span class="pc bpc" id="L744" title="1 of 4 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-f&quot;.equals(second)) {</span>
<span class="fc" id="L745">				getMentions(third);</span>
			} else {
<span class="fc" id="L747">				System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot;'&quot; + NOTVALIDCOMMAND);</span>
			}
<span class="fc" id="L749">			break;</span>
		case FOUR:
<span class="fc" id="L751">			first = args[ZERO];</span>
<span class="fc" id="L752">			second = args[ONE];</span>
<span class="fc" id="L753">			third = args[TWO];</span>
<span class="fc" id="L754">			fourth = args[THREE];</span>
<span class="pc bpc" id="L755" title="2 of 6 branches missed.">			if (&quot;members&quot;.equals(first) &amp;&amp; CHPARAMETER.equals(second) &amp;&amp; &quot;-f&quot;.equals(third)) {</span>
<span class="fc" id="L756">				getMembersForChannels(fourth);</span>
<span class="pc bpc" id="L757" title="2 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; &quot;-f&quot;.equals(third)) {</span>
<span class="fc" id="L758">				getMentionsWeighed(fourth);</span>
			} else {
<span class="fc" id="L760">				System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot; &quot; + fourth + &quot;'&quot; + NOTVALIDCOMMAND);</span>
			}
<span class="fc" id="L762">			break;</span>
		case FIVE:
<span class="fc" id="L764">			first = args[ZERO];</span>
<span class="fc" id="L765">			second = args[ONE];</span>
<span class="fc" id="L766">			third = args[TWO];</span>
<span class="fc" id="L767">			fourth = args[THREE];</span>
<span class="fc" id="L768">			fifth = args[FOUR];</span>
<span class="pc bpc" id="L769" title="2 of 6 branches missed.">			if (&quot;members&quot;.equals(first) &amp;&amp; CHPARAMETER.equals(second) &amp;&amp; &quot;-f&quot;.equals(fourth)) {</span>
<span class="fc" id="L770">				getMembersOfChannel(fifth, third);</span>
<span class="pc bpc" id="L771" title="1 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; CHPARAMETER.equals(second) &amp;&amp; &quot;-f&quot;.equals(fourth)) {</span>
<span class="fc" id="L772">				getMentions(fifth, third);</span>
<span class="pc bpc" id="L773" title="1 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; TOPARAMETER.equals(second) &amp;&amp; &quot;-f&quot;.equals(fourth)) {</span>
<span class="fc" id="L774">				getMentionsToUser(fifth, third);</span>
<span class="pc bpc" id="L775" title="2 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; FROMPARAMETER.equals(second) &amp;&amp; &quot;-f&quot;.equals(fourth)) {</span>
<span class="fc" id="L776">				getMentionsFromUser(fifth, third);</span>
			} else {
<span class="fc" id="L778">				System.out.println(</span>
						&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot; &quot; + fourth + &quot; &quot; + fifth + &quot;'&quot; + NOTVALIDCOMMAND);
			}
<span class="fc" id="L781">			break;</span>
		case SIX:
<span class="fc" id="L783">			first = args[ZERO];</span>
<span class="fc" id="L784">			second = args[ONE];</span>
<span class="fc" id="L785">			third = args[TWO];</span>
<span class="fc" id="L786">			fourth = args[THREE];</span>
<span class="fc" id="L787">			fifth = args[FOUR];</span>
<span class="fc" id="L788">			sixth = args[FIVE];</span>
<span class="pc bpc" id="L789" title="1 of 6 branches missed.">			if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; FROMPARAMETER.equals(third)</span>
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">					&amp;&amp; &quot;-f&quot;.equals(fifth)) {</span>
<span class="fc" id="L791">				getMentionsFromUserWeighed(sixth, fourth);</span>
<span class="pc bpc" id="L792" title="1 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; CHPARAMETER.equals(third)</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">					&amp;&amp; &quot;-f&quot;.equals(fifth)) {</span>
<span class="fc" id="L794">				getMentionsWeighed(sixth, fourth);</span>
<span class="pc bpc" id="L795" title="2 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; TOPARAMETER.equals(third)</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">					&amp;&amp; &quot;-f&quot;.equals(fifth)) {</span>
<span class="fc" id="L797">				getMentionsToUserWeighed(sixth, fourth);</span>
			} else {
<span class="fc" id="L799">				System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot; &quot; + fourth + &quot; &quot; + fifth + &quot;'&quot; + sixth</span>
						+ &quot;'&quot; + NOTVALIDCOMMAND);
			}
<span class="fc" id="L802">			break;</span>
		case SEVEN:
<span class="fc" id="L804">			first = args[ZERO];</span>
<span class="fc" id="L805">			second = args[ONE];</span>
<span class="fc" id="L806">			third = args[TWO];</span>
<span class="fc" id="L807">			fourth = args[THREE];</span>
<span class="fc" id="L808">			fifth = args[FOUR];</span>
<span class="fc" id="L809">			sixth = args[FIVE];</span>
<span class="fc" id="L810">			seventh = args[SIX];</span>
<span class="pc bpc" id="L811" title="1 of 6 branches missed.">			if (MENTIONSCOMMAND.equals(first) &amp;&amp; TOPARAMETER.equals(second) &amp;&amp; CHPARAMETER.equals(fourth)</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">					&amp;&amp; &quot;-f&quot;.equals(sixth)) {</span>
<span class="fc" id="L813">				getMentionsToUser(seventh, fifth, third);</span>
<span class="pc bpc" id="L814" title="2 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; FROMPARAMETER.equals(second) &amp;&amp; CHPARAMETER.equals(fourth)</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">					&amp;&amp; &quot;-f&quot;.equals(sixth)) {</span>
<span class="fc" id="L816">				getMentionsFromUser(seventh, fifth, third);</span>
			} else {
<span class="fc" id="L818">				System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot; &quot; + fourth + &quot; &quot; + fifth + &quot; &quot; + sixth</span>
						+ &quot; &quot; + seventh + &quot;'&quot; + NOTVALIDCOMMAND);
			}
<span class="fc" id="L821">			break;</span>
		case EIGHT:
<span class="fc" id="L823">			first = args[ZERO];</span>
<span class="fc" id="L824">			second = args[ONE];</span>
<span class="fc" id="L825">			third = args[TWO];</span>
<span class="fc" id="L826">			fourth = args[THREE];</span>
<span class="fc" id="L827">			fifth = args[FOUR];</span>
<span class="fc" id="L828">			sixth = args[FIVE];</span>
<span class="fc" id="L829">			seventh = args[SIX];</span>
<span class="fc" id="L830">			eighth = args[SEVEN];</span>
<span class="pc bpc" id="L831" title="1 of 6 branches missed.">			if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; TOPARAMETER.equals(third)</span>
<span class="pc bpc" id="L832" title="2 of 4 branches missed.">					&amp;&amp; CHPARAMETER.equals(fifth) &amp;&amp; &quot;-f&quot;.equals(seventh)) {</span>
<span class="fc" id="L833">				getMentionsToUserWeighed(eighth, sixth, fourth);</span>
<span class="pc bpc" id="L834" title="2 of 6 branches missed.">			} else if (MENTIONSCOMMAND.equals(first) &amp;&amp; &quot;-w&quot;.equals(second) &amp;&amp; FROMPARAMETER.equals(third)</span>
<span class="pc bpc" id="L835" title="2 of 4 branches missed.">					&amp;&amp; CHPARAMETER.equals(fifth) &amp;&amp; &quot;-f&quot;.equals(seventh)) {</span>
<span class="fc" id="L836">				getMentionsFromUserWeighed(eighth, sixth, fourth);</span>
			} else {
<span class="fc" id="L838">				System.out.println(&quot;'&quot; + first + &quot; &quot; + second + &quot; &quot; + third + &quot; &quot; + fourth + &quot; &quot; + fifth + &quot; &quot; + sixth</span>
						+ &quot; &quot; + seventh + &quot; &quot; + eighth + &quot;'&quot; + NOTVALIDCOMMAND);
			}
<span class="fc" id="L841">			break;</span>
		default:
<span class="fc" id="L843">			System.out.println(&quot;Command not found, see 'help'.&quot;);</span>
			break;
		}
<span class="fc" id="L846">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>